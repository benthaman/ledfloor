+ DPRAM
http://search.digikey.com/scripts/DkSearch/dksus.dll?Detail&name=428-2156-ND

+ Wiki
http://www.avrfreaks.net/wiki/index.php/Documentation:NGW

+ AVR32 atngw100
board setup code dans arch/avr32/boards/atngw100/setup.c

+ Kernel
pour voir les codes d'erreurs, chercher la définition de EINVAL (dans
include/asm-generic/errno-base.h)

struct file* filp; représente un open file descriptor
struct inode* inode; représente un fichier (sur disque, dans le vfs)

Il n'est pas permis de générer des page faults dans le kernel. S'il y en a ça
résulte en un oops.

Exemple d'un device qui utilise les GPIO, qui est un platform device et une
autre classe (input dans ce cas): drivers/input/keyboard/gpio_keys.c

+ GPIO
#include <include/asm/gpio.h>
Documentation/gpio.txt

++ particularités atmel
#include <mach/at32ap700x.h>
#include <mach/portmux.h>

at32_select_gpio(unsigned int pin, unsigned long flags)
pin: GPIO_PIN_PB(0), ...
flags: AT32_GPIOF_OUTPUT

+ Interface
un seul peut ouvrir en écriture, les autres bloquent ou fail avec Device Busy
autant que l'on veut peuvent ouvrir en lecture

+ Ledfloor
convertir et afficher une image:
convert test.png -resize 48x24 RGB:- | display -depth 8 -size 48x24 -sample
480 RGB:-

+ Todo
* retirer les ifdef de plateforme x86
* adaptation de blinkenlights pour utiliser le driver mplayer
* faire un vrai framebuffer device (pas vraiment utile)
* paramétrer la taille de l'écran
	* par une option module
	* par des ioctl
	* en écrivant/lisant une structure avec plus d'information
* race condition dans l'io s'il y a lecture d'un frame et écriture par dessus
  d'un nouveau frame
* pouvoir lire la valeur du frame limiter à partir de /sys
	* et la paramétrer (par un define et option module) comme un genre de
	  vsync
* implanter fsync pour que l'application puisse attendre que le frame ait été
  "clocké" avant d'écrire le prochain frame
  LDD p.166 "Never make a write call wait for data transmission before
  returning"
* programme d'affichage ncurses de ce qui devrait être sur l'écran
* io bloquant et non bloquant:
  Avoir une waitqueue wq et un numéro de frame fnum
  Lecture bloquante, wait_event_interruptible(wa, fnum > i), lire un frame
  Lecture non bloquante, lire un frame
  Écriture toujours "non-bloquante", prend du temps lorsque le frame est
  complet et doit être écrit sur les gpio, fnum++, wake_up_interruptible(wq)
* déplacer ledfloor.h et le code pour registerer le device dans le même
  répertoire que <mach/at32ap700x.h> et dans le board setup code

+ TooDone
* driver char-dev dans lequel on peut écrire 24 rangées * 48 colonnes * 3
  couleurs * 8 bits
* changer les gpio lorsque l'on vient d'écrire cela
* code pour créer le device node (avec device_create,
  http://kerneltrap.org/node/16688)
* programme pour convertir raw RGB <-> format nécessaire pour le sortir
	* intégrer ces changements dans le driver pour plus de simplicité. Il
	  s'agit seulement de changer l'ordre de lecture dans le buffer et il
	  s'agit de quelquechose de spécifique à ce device, un autre ledfloor
	  serait peut-être implanté différement.
